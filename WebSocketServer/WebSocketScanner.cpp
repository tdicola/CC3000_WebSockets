/* Generated by re2c 0.13.5 on Fri Nov  1 19:52:33 2013 */
#line 1 "WebSocketScanner.cpp.re"
#include "WebSocketScanner.h"

#include "Adafruit_CC3000_Server.h"
#include "string.h"

WebSocketScanner::WebSocketScanner(Adafruit_CC3000_ClientRef& client)
  : _client(client)
  , _cursor(_buffer)
  , _limit(_buffer)
  , _current(_buffer)
  , _marker(0)
  , _state(-1)
{
  loadBuffer();
  // TODO: Think about what happens when client disconnected.
}

int WebSocketScanner::nextToken() {
  _state = -1;
  _current = _cursor;
  int n = scan();
  if (n == NEED_DATA && _client.available()) {
    // Need more data, drop processed tokens and try to load more data
    dropOldTokens();
    return scan();
  }
  return n;
}

int WebSocketScanner::tokenLength() {
  return _cursor - _current;
}

char* WebSocketScanner::tokenData() {
  return _current;
}

bool WebSocketScanner::bufferAvailable() {
  return (_limit - _buffer) < _bufsize;
}

void WebSocketScanner::loadBuffer() {
  while (_client.available() && bufferAvailable()) {
    *_limit++ = _client.read();
  }
}

void WebSocketScanner::dropOldTokens() {
  // Calculate how much data after the last processed token is in the buffer.
  int remaining = _bufsize - (_current - _buffer);
  if (remaining > 0) {
    // Move remaining data to the front of the buffer, dropping old data.
    memmove(_buffer, _current, remaining);
    // Calculate how much data was dropped from the buffer.
    int dropped = _bufsize - remaining;
    // Clear out new open buffer spaces.
    memset(_buffer + remaining, 0, dropped);
    // Shift pointers back by amount of data dropped.
    _limit -= dropped;
    _cursor -= dropped;
    _marker -= dropped;
    // Move the last processed token pointer to the start.
    _current = _buffer;
    // Load new data.
    loadBuffer();
  }
  else {
    // Need more data but the buffer is full processing the current token.
    // No choice but to kill the data in the buffer and pull in more data.
    // This will lose information, so make sure the buffer is set to a size
    // larger than the smallest identifier measureable.
    // TODO: Think about setting a flag when this happens so the caller knows
    // a token is clipped.
    memset(_buffer, 0, _bufsize);
    _cursor = _buffer;
    _limit = _buffer;
    _current = _buffer;
    _marker = _buffer;
    loadBuffer();
  }
}

#define YYGETSTATE()  _state
#define YYSETSTATE(x)   { _state = x; }
#define YYFILL(n)     { return NEED_DATA; }

int WebSocketScanner::scan()
{

#line 93 "<stdout>"

	switch (YYGETSTATE()) {
	default: goto yy0;
	case 0: goto yyFillLabel0;
	case 1: goto yyFillLabel1;
	case 2: goto yyFillLabel2;
	}
yy0:
	YYSETSTATE(0);
	if ((_limit - _cursor) < 3) YYFILL(3);
yyFillLabel0:
	_ch = *_cursor;
	switch (_ch) {
	case '\t':
	case '\n':
	case ' ':	goto yy9;
	case '\r':	goto yy7;
	case ':':	goto yy2;
	default:	goto yy4;
	}
yy2:
	++_cursor;
#line 97 "WebSocketScanner.cpp.re"
	{ return COLON; }
#line 118 "<stdout>"
yy4:
	++_cursor;
	YYSETSTATE(1);
	if (_limit <= _cursor) YYFILL(1);
yyFillLabel1:
	_ch = *_cursor;
	switch (_ch) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':
	case ':':	goto yy6;
	default:	goto yy4;
	}
yy6:
#line 98 "WebSocketScanner.cpp.re"
	{ return IDENTIFIER; }
#line 136 "<stdout>"
yy7:
	++_cursor;
	switch ((_ch = *_cursor)) {
	case '\n':	goto yy11;
	default:	goto yy10;
	}
yy8:
#line 100 "WebSocketScanner.cpp.re"
	{ _current = _cursor; goto yy0; }
#line 146 "<stdout>"
yy9:
	++_cursor;
	YYSETSTATE(2);
	if (_limit <= _cursor) YYFILL(1);
yyFillLabel2:
	_ch = *_cursor;
yy10:
	switch (_ch) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy9;
	default:	goto yy8;
	}
yy11:
	++_cursor;
	switch ((_ch = *_cursor)) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy9;
	default:	goto yy12;
	}
yy12:
#line 99 "WebSocketScanner.cpp.re"
	{ return EOL; }
#line 173 "<stdout>"
#line 101 "WebSocketScanner.cpp.re"

}

//  [^\x00-\x1f\x7f()<>@,;:\x5c\x22\x2f\x5b\x5d?={} ]+    { return 0; }
//  "\r\n"                                                { return 1; }
//  [ \t\r\n]+                                            { return 2; }
//  "/"                                                   { return 3; }